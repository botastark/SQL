/*
BOTA DUISENBAY 
HW3 
25TH OF AUGUST 2020
*/
USE SECOND_WEEK
/*
TASK 1
RETURN ACCOUNT ID OF ACCOUNTS OPENNED IN A BRANCH WITH ADDRESS '422 Maple St.'

USED LEFT JOIN BRANCH TABLE TO ACCOUNT TABLE: TO ADD TO ACCOUNT DATA BRANCH ADDRESS BASED ON BRANCH ID.
THEN FROM THE RESULTANT TABLE SELECT ACCOUNT ID OF THOSE WITH THE ADDRESS '422 Maple St.'
*/
SELECT ACCOUNT_ID 
FROM ACCOUNT A
LEFT JOIN BRANCH B
ON A.OPEN_BRANCH_ID=B.BRANCH_ID
WHERE B.ADDRESS = '422 Maple St.'


/*
TASK 2
SHOW NAMES OF THOSE EMPLOYEES WHO HAVEN'T OPENED ACCOUNT FOR CLIENTS
EMPLOYEE TABLE IS ENRICHED WITH ACCOUNT BASED ON EMP_ID VIA LEFT JOIN, SO WE CAN SEE EACH EMPLOYEE'S OPENED ACCOUNTS
FROM THIS TABLE, WE SELECT EMPLOYEES WITH NO ACCOUNT (ACCOUNT_ID = NULL) AND RETURN THEIR FIRST AND LAST NAMES
*/

SELECT FIRST_NAME, LAST_NAME
FROM EMPLOYEE E
LEFT JOIN  ACCOUNT A
ON E.EMP_ID = A.OPEN_EMP_ID
WHERE A.ACCOUNT_ID IS NULL

/*
TASK 3
RETURN NAME OF DEPARTMENT AND NUMBER OF EMPLOYEE WORKING THERE SORTED ASC, WHERE NO LESS THAN 2 EMPLOYEES
FIRST EMPLOYEE TABLE IS JOINTED TO DEPARTMENT BASED ON DEPT_ID, SELECT COLUMNS DEPARTMENT NAME AND NUMBER OF EMPLOYEES EXTRACTED BY COUNT
AND GROUPED BY DEPARTMENT NAME. THEN DEPARTMENTS WITH MORE THAN 2 OF EMPLOYEES WHERE FILTER WITH HAVING AND LATER ORDERED
*/

SELECT D.NAME, COUNT(E.EMP_ID) AS NUMBER_OF_EMPLOYEES
FROM DEPARTMENT D 
LEFT JOIN EMPLOYEE E
ON D.DEPT_ID = E.DEPT_ID
GROUP BY D.NAME
HAVING COUNT(E.EMP_ID) > 2
ORDER BY COUNT(E.EMP_ID) ASC

/*
TASK 4

FIRST AS A SUBQUERY WE FIND MAX BALANCE FOR EACH BRANCH BY USING MAX AND GROUPING. STORE IT WITH PSEUDONAME M.
TABLE T IS A SUBTABLE OF ACCOUNT CONTAINING ALSO ACCOUNT_ID, APART FROM  AVAIL_BALANCE AND BRANCH ID 
THEN WITH A INNER JOIN WE COMPARE TWO TABLES TO GET THE ACCOUNT ID: IF AVAIL_BALANCE AND OPEN_BRANCH_ID PAIRS IN TABLE M AND IN TABLE T MATCHES
*/

SELECT T.ACCOUNT_ID,T.OPEN_BRANCH_ID , T.AVAIL_BALANCE
    FROM ( SELECT MAX(AVAIL_BALANCE) AS MAX_BALANCE, OPEN_BRANCH_ID FROM ACCOUNT GROUP BY OPEN_BRANCH_ID) AS M
INNER JOIN ACCOUNT AS T
ON T.OPEN_BRANCH_ID=M.OPEN_BRANCH_ID AND T.AVAIL_BALANCE=M.MAX_BALANCE

/*
TASK 5
FIRST, FIND MAX_BALANCE FOR THE WHOLE TABLE, 
AND MAKE A PSEUDO TABLE M WITH ACCOUNT_ID AND AVAIL_BALANCE AS COLUMNS, WITH AVAIL_BALANCE EQUAL TO MAX_BALANCE
MAKE INNER JOIN WITH TABLE T (ACCOUNT), THAT OUTPUTS ACCOUNT_ID FOR MATCHING ACCOUNT_IDS
*/

SELECT T.ACCOUNT_ID, T.CLOSE_DATE FROM (
    SELECT ACCOUNT_ID, AVAIL_BALANCE FROM ACCOUNT
    WHERE AVAIL_BALANCE = (SELECT MAX(AVAIL_BALANCE) AS MAX_BALANCE FROM ACCOUNT)) AS M
INNER JOIN ACCOUNT AS T
ON T.ACCOUNT_ID=M.ACCOUNT_ID

/*
TASK 6
 JOIN ACCOUNT AND BRANCH TABLES BY BRANCH_ID, THEN RETRIEVE SUM OF AVAILABLE BALANCE FOR EACH CITY VIA GROUPING BY CITY
 TO THIS VIA UNION ADD A ROW THAT HAS VARCHAR 'TOTALSUM' AND SUM OF ALL AVAIL_BALANCE FROM TABLE ACCOUNT AS COLUMNS
 THE ORDER OF COLUMNS ARE IMPORTNANT AS DATATYPES MUST MATCH IN ORDER TO DO UNION
 FINALLY TO KEEP AN ORDER (TOTALSUM APPEAR AS THE LAST ROW), PUT ORDERING BY CUM_BALANCE AS TOTAL WILL ALWAYS BE THE LARGEST
*/

SELECT CITY, SUM(AVAIL_BALANCE) AS CUM_BALANCE FROM ACCOUNT
LEFT JOIN BRANCH
ON ACCOUNT.OPEN_BRANCH_ID=BRANCH.BRANCH_ID
GROUP BY CITY
UNION 
SELECT 'TOTALSUM', SUM(AVAIL_BALANCE) FROM ACCOUNT
ORDER BY CUM_BALANCE


/*
TASK 7
INNER JOINING ACCOUNT AND BRANCH TABLES BASED BRANCH ID, WE GET EMPLOYEE ID, WHO EVER OPENED ACCOUNT, BRANCH ID AND CORRESPONING CITY. PSEUDOTBALE M 
THEN LEFT JOINING PSEUDO TABLE M WITH EMPLOYEE TABLE VIA EMP_ID, WE ADD BRANCH CITIES TO THE EMPLOYEES, WHO EVER HAVE OPENED ACCOUNT, SO FOR THOSE WHOSE HAVEN'T IT STAY NULL
FROM THE RESULTANT TABLE WE PUT CONDTION THROUGH WHERE TO SELECT EMPLOYEES WHOSE TITLE IS PRESIDENT (NO MATTER THE CITY) AND EMPLOYYES WHO HAVE OPENED ACCOUNT IN CITY SALEM
*/

SELECT DISTINCT  FIRST_NAME, LAST_NAME FROM EMPLOYEE AS E
LEFT JOIN
(
    SELECT DISTINCT A.OPEN_BRANCH_ID, A.OPEN_EMP_ID, B.CITY FROM ACCOUNT AS A
    JOIN BRANCH AS B
    ON A.OPEN_BRANCH_ID=B.BRANCH_ID
    
    ) AS M

ON M.OPEN_EMP_ID=E.EMP_ID
WHERE E.TITLE='President' OR CITY = 'Salem'
/*
TASK 8

In a subquery joining customer table to account table to have an address for each cust id, 
                    gets sum of avail balance for each cust id, and then select sum avail balance of the one with address '7 Industrial Way'
Calculate sum of avail balance for each cust id and selects the cust ids whose total  balance is less than the retrieved balance 


*/
SELECT SUM(A.AVAIL_BALANCE) AS TOTAL_BALANCE, A.CUST_ID FROM ACCOUNT AS A
GROUP BY  A.CUST_ID
HAVING SUM(A.AVAIL_BALANCE) <
(
    SELECT SUM(A.AVAIL_BALANCE) AS BALANCE FROM ACCOUNT AS A
    LEFT JOIN CUSTOMER AS C
    ON C.CUST_ID=A.CUST_ID
    WHERE C.ADDRESS='7 Industrial Way'   
    GROUP BY A.CUST_ID
)